library msk.pf.src.id;

final _lut = new List<int>.generate(256, (i) => i)
  ..setRange(0x40, 0x5B, new Iterable.generate(0x5C - 0x40, (i) => i + 0x60));

const commonMagic =
    ((-0x340d631c) & 0xFFFFFFFF) << 32 | (-0x7bdddcdb) & 0xFFFFFFFF;

String formatId(int id) {
  if (id.isNegative) {
    return ((id >> 32)
            .toUnsigned(32)
            .toRadixString(16)
            .toUpperCase()
            .padLeft(8, '0') +
        id.toUnsigned(32).toRadixString(16).toUpperCase().padLeft(8, '0'));
  } else {
    return id.toRadixString(16).toUpperCase().padLeft(16, '0');
  }
}

int computeId(List<int> r3) {
  int r4 = 1;
  int r5 = (-0x340d631c) & 0xFFFFFFFF;
  int r6 = (-0x7bdddcdb) & 0xFFFFFFFF;
  const int r7 = 256;
  const int r8 = 435;

  for (int i = 0; i < r3.length; i++) {
    int r0 = r3[i];
    r4 = (r6 * r8) >> 32;
    int r10 = _lut[r0];
    int r9 = (r10 >> 31) & 0xFFFFFFFF;
    r5 = (r5 * r8) & 0xFFFFFFFF;
    r0 = (r6 * r7) & 0xFFFFFFFF;
    r4 = (r4 + r5) & 0xFFFFFFFF;
//    print((r6 * r8).toRadixString(16).padLeft(16, '0'));
//    print(r6 * r8);
    r6 = (r6 * r8) & 0xFFFFFFFF;
    r0 = (r4 + r0) & 0xFFFFFFFF;
    r5 = (r9 ^ r0) & 0xFFFFFFFF;
    r6 = (r10 ^ r6) & 0xFFFFFFFF;
  }
  return (r5 << 32) | r6;
}

int f(int x, int y) => y * (2 - y * x);
int inv32(int x) => f(x, f(x, f(x, f(x, x))));
int inv64(int x) => f(x, f(x, f(x, f(x, f(x, x)))));

final i435 = inv32(435);
final i435_64 = inv64(435).toUnsigned(64); // & 0xFFFFFFFFFFFFFFFF;

const invertUpperBit = const [
  0x0000, 0x6a85, 0xd50a, 0x3f8f, 0xaa14, 0x1499, 0x7f1e, 0xe9a3, 0x5428, //
  0xbead, 0x2932, 0x93b7, 0xfe3c, 0x68c1, 0xd346, 0x3dcb, 0xa850, 0x12d5, //
  0x7d5a, 0xe7df, 0x5264, 0xbce9, 0x276e, 0x91f3, 0xfc78, 0x66fd, 0xd182, //
  0x3c07, 0xa68c, 0x1111, 0x7b96, 0xe61b, 0x50a0, 0xbb25, 0x25aa, 0x902f, //
  0xfab4, 0x6539, 0xcfbe, 0x3a43, 0xa4c8, 0x0f4d, 0x79d2, 0xe457, 0x4edc, //
  0xb961, 0x23e6, 0x8e6b, 0xf8f0, 0x6375, 0xcdfa, 0x387f, 0xa304, 0x0d89, //
  0x780e, 0xe293, 0x4d18, 0xb79d, 0x2222, 0x8ca7, 0xf72c, 0x61b1, 0xcc36, //
  0x36bb, 0xa140, 0x0bc5, 0x764a, 0xe0cf, 0x4b54, 0xb5d9, 0x205e, 0x8ae3, //
  0xf568, 0x5fed, 0xca72, 0x34f7, 0x9f7c, 0x0a01, 0x7486, 0xdf0b, 0x4990, //
  0xb415, 0x1e9a, 0x891f, 0xf3a4, 0x5e29, 0xc8ae, 0x3333, 0x9db8, 0x083d, //
  0x72c2, 0xdd47, 0x47cc, 0xb251, 0x1cd6, 0x875b, 0xf1e0, 0x5c65, 0xc6ea, //
  0x316f, 0x9bf4, 0x0679, 0x70fe, 0xdb83, 0x4608, 0xb08d, 0x1b12, 0x8597, //
  0xf01c, 0x5aa1, 0xc526, 0x2fab, 0x9a30, 0x04b5, 0x6f3a, 0xd9bf, 0x4444, //
  0xaec9, 0x194e, 0x83d3, 0xee58, 0x58dd, 0xc362, 0x2de7, 0x986c, 0x02f1, //
  0x6d76, 0xd7fb, 0x4280, 0xad05, 0x178a, 0x820f, 0xec94, 0x5719, 0xc19e, //
  0x2c23, 0x96a8, 0x012d, 0x6bb2, 0xd637, 0x40bc, 0xab41, 0x15c6, 0x804b, //
  0xead0, 0x5555, 0xbfda, 0x2a5f, 0x94e4, 0xff69, 0x69ee, 0xd473, 0x3ef8, //
  0xa97d, 0x1402, 0x7e87, 0xe90c, 0x5391, 0xbe16, 0x289b, 0x9320, 0xfda5, //
  0x682a, 0xd2af, 0x3d34, 0xa7b9, 0x123e, 0x7cc3, 0xe748, 0x51cd, 0xbc52, //
  0x26d7, 0x915c, 0xfbe1, 0x6666, 0xd0eb, 0x3b70, 0xa5f5, 0x107a, 0x7aff, //
  0xe584, 0x5009, 0xba8e, 0x2513, 0x8f98, 0xfa1d, 0x64a2, 0xcf27, 0x39ac, //
  0xa431, 0x0eb6, 0x793b, 0xe3c0, 0x4e45, 0xb8ca, 0x234f, 0x8dd4, 0xf859, //
  0x62de, 0xcd63, 0x37e8, 0xa26d, 0x0cf2, 0x7777, 0xe1fc, 0x4c81, 0xb706, //
  0x218b, 0x8c10, 0xf695, 0x611a, 0xcb9f, 0x3624, 0xa0a9, 0x0b2e, 0x75b3, //
  0xe038, 0x4abd, 0xb542, 0x1fc7, 0x8a4c, 0xf4d1, 0x5f56, 0xc9db, 0x3460, //
  0x9ee5, 0x096a, 0x73ef, 0xde74, 0x48f9, 0xb37e, 0x1e03, 0x8888, 0xf30d, //
  0x5d92, 0xc817, 0x329c, 0x9d21, 0x07a6, 0x722b, 0xdcb0, 0x4735, 0xb1ba, //
  0x1c3f, 0x86c4, 0xf149, 0x5bce, 0xc653, 0x30d8, 0x9b5d, 0x05e2, 0x7067, //
  0xdaec, 0x4571, 0xaff6, 0x1a7b, 0x8500, 0xef85, 0x5a0a, 0xc48f, 0x2f14, //
  0x9999, 0x041e, 0x6ea3, 0xd928, 0x43ad, 0xae32, 0x18b7, 0x833c, 0xedc1, //
  0x5846, 0xc2cb, 0x2d50, 0x97d5, 0x025a, 0x6cdf, 0xd764, 0x41e9, 0xac6e, //
  0x16f3, 0x8178, 0xebfd, 0x5682, 0xc107, 0x2b8c, 0x9611, 0x0096, 0x6b1b, //
  0xd5a0, 0x4025, 0xaaaa, 0x152f, 0x7fb4, 0xea39, 0x54be, 0xbf43, 0x29c8, //
  0x944d, 0xfed2, 0x6957, 0xd3dc, 0x3e61, 0xa8e6, 0x136b, 0x7df0, 0xe875, //
  0x52fa, 0xbd7f, 0x2804, 0x9289, 0xfd0e, 0x6793, 0xd218, 0x3c9d, 0xa722, //
  0x11a7, 0x7c2c, 0xe6b1, 0x5136, 0xbbbb, 0x2640, 0x90c5, 0xfb4a, 0x65cf, //
  0xd054, 0x3ad9, 0xa55e, 0x0fe3, 0x7a68, 0xe4ed, 0x4f72, 0xb9f7, 0x247c, //
  0x8f01, 0xf986, 0x640b, 0xce90, 0x3915, 0xa39a, 0x0e1f, 0x78a4, 0xe329, //
  0x4dae, 0xb833, 0x22b8, 0x8d3d, 0xf7c2, 0x6247, 0xcccc, 0x3751, 0xa1d6, //
  0x0c5b, 0x76e0, 0xe165, 0x4bea, 0xb66f, 0x20f4, 0x8b79, 0xf5fe, 0x6083, //
  0xcb08, 0x358d, 0xa012, 0x0a97, 0x751c, 0xdfa1, 0x4a26, 0xb4ab, 0x1f30, //
  0x89b5, 0xf43a, 0x5ebf, 0xc944, 0x33c9, 0x9e4e, 0x08d3, 0x7358, 0xdddd, //
  0x4862, 0xb2e7, 0x1d6c, 0x87f1, 0xf276, 0x5cfb, 0xc780, 0x3205, 0x9c8a, //
  0x070f, 0x7194, 0xdc19, 0x469e, 0xb123, 0x1ba8, 0x862d, 0xf0b2, 0x5b37, //
  0xc5bc, 0x3041, 0x9ac6, 0x054b, 0x6fd0, 0xda55, 0x44da, 0xaf5f, 0x19e4, //
  0x8469, 0xeeee, 0x5973, 0xc3f8, 0x2e7d, 0x9902, 0x0387, 0x6e0c, 0xd891, //
  0x4316, 0xad9b, 0x1820, 0x82a5, 0xed2a, 0x57af, 0xc234, 0x2cb9, 0x973e, //
  0x01c3, 0x6c48, 0xd6cd, 0x4152, 0xabd7, 0x165c, 0x80e1, 0xeb66, 0x55eb, //
  0xc070, 0x2af5, 0x957a, //
];

final bitsToUpperMul = new Map<int, int>.fromIterables(
    invertUpperBit, new Iterable.generate(435, (i) => i));

Iterable<int> solveId(int id) sync* {
  final int r5 = (id >> 32) & 0xFFFFFFFF;
  final int r6 = id & 0xFFFFFFFF;

  const int r8 = 435;

  for (int i = 0x61; i < 0x60 + 26; i++) {
    int r10 = _lut[i];

    int r6PreXor = r10 ^ r6;

    int r6Inv = r6PreXor * i435;
    int bits = (r6Inv >> 32) & 0xFFFF;
    int r6MulUpperBits = bitsToUpperMul[bits];

    print(bits.toRadixString(16));

    if (r6MulUpperBits == null) continue;

    int r6PreXorFull = (r6MulUpperBits << 32) | r6PreXor;
    int r6PreMul = r6Inv & 0xFFFFFFFF;

//    print(i435_64.toRadixString(16));
    print(r6PreMul.toRadixString(16));
    print(r6PreMul * r8);
    print(r6PreXorFull);
    print("well");

    if ((r6PreMul & ~0xFFFFFFFF) != 0) continue; // Not correct, garbage result

    r6MulUpperBits = (r6PreMul * r8) >> 32;
    print(r6MulUpperBits);
    print(r6PreXorFull);
    print("!!");

//    print(r6PreXorFull);

//    int r6PreMul = r6PreXorFull ~/ r8;

//    print(r6PreMul);

//    print("chr$r10 $r6MulUpperBits $r6PreXor $r6PreXorFull $r6PreMul");

    // Proper r6, check r5
    int r5Pre = (r5 - ((r6PreXorFull >> 32) + ((r6PreMul << 8) & 0xFFFFFFFF))) &
        0xFFFFFFFF;

//    print(r5Pre);

    int r5PreFull = r5Pre;
    int r5MulUpperBits = 0;

    {
      bool ok = false;

      for (; r5MulUpperBits < r8; r5MulUpperBits++) {
        r5PreFull = (r5MulUpperBits << 32) | r5Pre;

        if ((r5PreFull % r8) == 0) {
          ok = true;
          break;
        }
      }

      if (!ok) continue;
    }

//    print("Found proper r6: $r10 $r5PreFull");

    int r5PreMul = r5PreFull ~/ r8;

    // Test it:
//    {
//      int r4 = 1;
//      int r5 = r5PreMul & 0xFFFFFFFF;
//      int r6 = r6PreMul & 0xFFFFFFFF;
//      const int r7 = 256;
//      const int r8 = 435;
//
//      int r0 = i;
//      r4 = (r6 * r8) >> 32;
//      int r10 = _lut[r0];
//      int r9 = (r10 >> 31) & 0xFFFFFFFF;
//      r5 = (r5 * r8) & 0xFFFFFFFF;
//      r0 = (r6 * r7) & 0xFFFFFFFF;
//      r4 = (r4 + r5) & 0xFFFFFFFF;
//      r6 = (r6 * r8) & 0xFFFFFFFF;
//      r0 = (r4 + r0) & 0xFFFFFFFF;
//      r5 = (r9 ^ r0) & 0xFFFFFFFF;
//      r6 = (r10 ^ r6) & 0xFFFFFFFF;
//
//      // print("$id ${r5 << 32 | r6} ${r5 - (id >> 32)} ${r6 - (id & 0xFFFFFFFF)}");
//
//      if (((r5 << 32) | r6) == id) {
////        print("OK! $r10 ${(r5PreMul << 32 | r6PreMul).toRadixString(16).padLeft(16, '0')}");
//        candidates++;
//        yield (r5PreMul << 32 | r6PreMul) | (r10 << 64);
//      }
//    }

//    print("OK! $r10 ${(r5PreMul << 32 | r6PreMul).toRadixString(16).padLeft(16, '0')}");
    yield (r5PreMul << 32 | r6PreMul) | (r10 << 64);
  }

//  print("$candidates OK");
}
