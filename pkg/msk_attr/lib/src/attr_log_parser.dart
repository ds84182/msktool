library msk.attr.attr_log_parser;

import 'attr_data.dart';

import 'attr_log_grammar.dart';
import 'dart:async';
import 'package:file/file.dart';
import 'package:msk_attr/src/attr_context.dart';

AttrFlag _stringToFlag(String str) {
  switch(str) {
    case "kFlag_IsImportable":
      return AttrFlag.importable;
    case "kFlag_IsForced":
      return AttrFlag.forced;
    case "kFlag_IsReadOnly":
      return AttrFlag.readOnly;
    case "kFlag_IsInhertiable":
      return AttrFlag.inheritable;
    case "kFlag_IgnoreRefCount":
      return AttrFlag.ignoreRefCount;
    case "kFlag_IsArray":
      return AttrFlag.array;
    case "kFlag_IsFixedArray":
      return AttrFlag.fixedArray;
    case "kFlag_IsSerializable":
      return AttrFlag.serializable;
    case "kFlag_IsCloneable":
      return AttrFlag.cloneable;
    case "kFlag_IsAutoGenerated":
      return AttrFlag.autoGenerated;
  }
  throw str;
}

class AttrParser {
  final AttrContext context;
  final Iterator<String> lines;

  final Map<int, AttrClass> classMap = {};
  final Map<int, AttrType> typeMap = {};
  final Map<int, List<AttrCollection>> collectionMap = {};

  AttrParser(this.context, this.lines);

  AttrClass parseClass() {
    final parsed = attrClass.parse(lines.current);

    if (parsed is Success) {
      // print("Class");
      // print(parsed);

      context.addName(parsed.value[0][0], parsed.value[0][1]);

      final c = new AttrClass(
        id: parsed.value[0][1],
        flags: new Set.from((parsed.value[1] as List<String>).map(_stringToFlag)),
      );

      classMap[c.id] = c;
      context.addClass(c);

      lines.moveNext();

      context.addFieldsToClass(c.id, () sync* {
        while (true) {
          final field = parseField(c);
          if (field == null) break;
          yield field;
        }
      } ());

      return c;
    }

    return null;
  }

  AttrField parseField(AttrClass clazz) {
    final parsed = attrField.parse(lines.current);

    if (parsed is Success) {
      // print("Field");
      // print(parsed);

      context.addName(parsed.value[0][0], parsed.value[0][1]);
      context.addName(parsed.value[1][0], parsed.value[1][1]);

      final f = new AttrField(
        id: parsed.value[0][1],
        type: context.lookupOrCreateType(
          parsed.value[1][1],
          parsed.value[3],
        ),
        flags: new Set.from((parsed.value[2] as List<String>).map(_stringToFlag)),
      );

      lines.moveNext();

      return f;
    }

    return null;
  }

  AttrCollection parseCollection() {
    final parsed = attrCollection.parse(lines.current);

    if (parsed is Success) {
      // print("Collection");
      // print(parsed);

      final classId = parsed.value[0][1];

      context.addName(parsed.value[1][0], parsed.value[1][1]);

      final c = new AttrCollection(
        id: parsed.value[1][1],
        classId: classId,
        flags: new Set.from((parsed.value[2] as List<String>).map(_stringToFlag)),
      );

      collectionMap
          .putIfAbsent(classId, () => [])
          .add(c);

      lines.moveNext();

      return c;
    }

    return null;
  }

  void parse() {
    if (!lines.moveNext()) return;

    outer:
    do {
      // The parse<X> functions are required to moveNext after a successful
      // parse.
      // When all parse functions fail we skip to the next line.
      // While the current line is blank (after trimming whitespace), skip to next line.
      // In any event we reach the end of available lines, we break out of the loop.
      if (parseClass() != null) continue;
      if (parseCollection() != null) continue;
      if (!lines.moveNext()) break;
      while (lines.current.trim().isEmpty) {
        if (!lines.moveNext()) {
          break outer;
        }
      }
    } while (true);

    collectionMap.forEach(context.addCollectionsToClass);
  }
}

Future parseLogFile(AttrContext context, File file) async {
  final lines = await file.readAsLines();
  final parser = new AttrParser(context, lines.iterator);
  parser.parse();
}
